{"version":3,"file":"operators.js","sourceRoot":"","sources":["../src/operators.ts"],"names":[],"mappings":"AAAA,OAAO,EAAc,KAAK,EAAoB,MAAM,MAAM,CAAC;AAC3D,OAAO,EAAE,MAAM,EAAE,GAAG,EAAE,SAAS,EAAE,cAAc,EAAE,GAAG,EAAE,YAAY,EAAE,MAAM,gBAAgB,CAAC;AAE3F,MAAM,UAAU,aAAa,CAAI,EAAuB;IACtD,OAAO,CAAC,MAAqB,EAAE,EAAE;QAC/B,OAAO,EAAE,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;IACvD,CAAC,CAAC;AACJ,CAAC;AAED,MAAM,UAAU,eAAe,CAAI,EAAuB;IACxD,OAAO,CAAC,MAAqB,EAAE,EAAE;QAC/B,OAAO,EAAE,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC;IACvD,CAAC,CAAC;AACJ,CAAC;AAED,2DAA2D;AAC3D,wCAAwC;AACxC,0BAA0B;AAC1B,4BAA4B;AAC5B,8BAA8B;AAC9B,wBAAwB;AACxB,SAAS;AACT,OAAO;AACP,KAAK;AAEL,MAAM,UAAU,UAAU,CAAI,EAAuB,EAAE,GAAG,MAA6B;IACrF,OAAO,CAAC,MAAqB,EAAE,EAAE;QAC/B,IAAI,MAAM,CAAC,MAAM,KAAK,CAAC,EAAE;YACvB,OAAO,MAAM,CAAC,IAAI,CAChB,cAAc,CAAC,EAAE,CAAC,EAClB,MAAM,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,EACpB,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,CAChB,CAAC;SACH;QAED,OAAO,MAAM,CAAC,IAAI,CAChB,cAAc,CAAC,EAAE,EAAE,GAAG,MAAM,CAAC,EAC7B,MAAM,CAAC,CAAC,CAAC,EAAE,GAAG,EAAE,CAAC,EAAE,EAAE,CAAC,EAAE,CAAC,KAAK,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,EACvC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAM,CAAC,CACrB,CAAC;IACJ,CAAC,CAAC;AACJ,CAAC;AAAA,CAAC;AAEF,MAAM,UAAU,kBAAkB,CAAI,OAAe,CAAC;IACpD,OAAO,CAAC,MAAqB,EAAE,EAAE;QAC/B,IAAI,cAAc,GAAQ,EAAE,CAAC;QAE7B,OAAO,MAAM,CAAC,IAAI,CAChB,GAAG,CAAC,KAAK,CAAC,EAAE,CAAC,cAAc,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,EACxC,YAAY,CAAC,IAAI,CAAC,EAClB,GAAG,CAAC,GAAG,EAAE,CAAC,cAAc,CAAC,EACzB,GAAG,CAAC,GAAG,EAAE,CAAC,cAAc,GAAG,EAAE,CAAC,CAC/B,CAAC;IACJ,CAAC,CAAC;AACJ,CAAC","sourcesContent":["import { Observable, NEVER, OperatorFunction } from \"rxjs\";\nimport { filter, map, switchMap, withLatestFrom, tap, debounceTime } from \"rxjs/operators\";\n\nexport function subscribeWhen<T>(p$: Observable<boolean>) {\n  return (source: Observable<T>) => {\n    return p$.pipe(switchMap(p => (p ? source : NEVER)));\n  };\n}\n\nexport function unsubscribeWhen<T>(p$: Observable<boolean>) {\n  return (source: Observable<T>) => {\n    return p$.pipe(switchMap(p => (p ? NEVER : source)));\n  };\n}\n\n// export function filterWhen<T>(p$: Observable<boolean>) {\n//   return (source: Observable<T>) => {\n//     return source.pipe(\n//       withLatestFrom(p$),\n//       filter(([, p]) => p),\n//       map(([x]) => x)\n//     );\n//   };\n// };\n\nexport function filterWhen<T>(p$: Observable<boolean>, ...others: Observable<boolean>[]) {\n  return (source: Observable<T>) => {\n    if (others.length === 0) {\n      return source.pipe(\n        withLatestFrom(p$),\n        filter(([, p]) => p),\n        map(([x]) => x)\n      );\n    }\n\n    return source.pipe(\n      withLatestFrom(p$, ...others),\n      filter(([, ...ps]) => ps.every(p => p)),\n      map(([x]) => x as T)\n    );\n  };\n};\n\nexport function bufferDebounceTime<T>(time: number = 0): OperatorFunction<T, T[]> {\n  return (source: Observable<T>) => {\n    let bufferedValues: T[] = [];\n\n    return source.pipe(\n      tap(value => bufferedValues.push(value)),\n      debounceTime(time),\n      map(() => bufferedValues),\n      tap(() => bufferedValues = []),\n    );\n  };\n}\n"]}