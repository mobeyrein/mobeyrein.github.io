var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { UUID } from 'uuid-class';
import { proofOfClap } from '@getclaps/proof-of-clap';
const API = Reflect.get(window, 'GET_CLAPS_API') || "https://worker.getclaps.app";
function paramsURL(url, params, base) {
    const u = new URL(url, base);
    for (const [k, v] of Object.entries(params || {}))
        u.searchParams.append(k, v);
    return u.href;
}
const fetchMap = new Map();
let referrerSent = false;
export const getClaps = (href, parentHref, referrer) => __awaiter(void 0, void 0, void 0, function* () {
    let indexPromise = fetchMap.get(parentHref);
    if (!indexPromise) {
        fetchMap.set(parentHref, indexPromise = fetchMap.get(parentHref) || (() => __awaiter(void 0, void 0, void 0, function* () {
            var _a;
            const url = paramsURL('/views', Object.assign({ href: parentHref }, referrer && !referrerSent ? { referrer } : {}), API);
            const response = yield fetch(url, {
                method: 'POST',
                body: null,
                mode: 'cors',
                credentials: 'include',
                headers: { 'accept': 'application/json' },
            });
            referrerSent = true;
            if (response.ok && ((_a = response.headers.get('Content-Type')) === null || _a === void 0 ? void 0 : _a.includes('json'))) {
                return yield response.json();
            }
            else if (response.status === 404) {
                return {};
            }
            else if (response.status === 402) {
                throw response;
            }
            else {
                fetchMap.delete(parentHref);
                throw Error();
            }
        }))());
    }
    const index = yield indexPromise;
    return index[href] || { claps: 0 };
});
export const mine = (claps, href) => __awaiter(void 0, void 0, void 0, function* () {
    const url = new URL(href);
    url.search = '';
    const id = new UUID();
    const nonce = yield proofOfClap({ url, claps, id });
    return { href: url.href, id, nonce };
});
export const updateClapsApi = (claps, href, parentHref, id, nonce) => __awaiter(void 0, void 0, void 0, function* () {
    var _b;
    const url = paramsURL('/claps', { href }, API);
    const response = yield fetch(url, {
        method: 'POST',
        body: JSON.stringify({ claps, id, nonce }),
        mode: 'cors',
        credentials: 'include',
        headers: {
            'accept': 'application/json',
            'content-type': 'application/json;charset=UTF-8',
        },
    });
    if (response.ok && ((_b = response.headers.get('Content-Type')) === null || _b === void 0 ? void 0 : _b.includes('json'))) {
        fetchMap.delete(parentHref); // TODO: update in place instead?
        return response.clone().json();
    }
    else {
        throw Error();
    }
});
export const cleanUp = (parentHref) => {
    fetchMap.delete(parentHref);
};
//# sourceMappingURL=api.js.map