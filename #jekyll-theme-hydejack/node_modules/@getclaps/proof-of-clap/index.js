import { UUID } from "uuid-class";
import { concatBufferSources } from 'typed-array-utils';
const BASE_DIFFICULTY = 8;
const BASE_CLAPS = 15;
const sha256 = (data) => crypto.subtle.digest('SHA-256', data);
const digest = (message) => sha256(new TextEncoder().encode(message));
async function makeKey({ url, id, claps, nonce }) {
    return concatBufferSources(await digest(url.toString()), new UUID(id.toString()), new Uint32Array([claps]), new Uint32Array([nonce])).buffer;
}
function leadingZeros(ab, n) {
    const u8 = new Uint8Array(ab);
    const nb = Math.ceil(n / 8);
    for (let i = 0; i < nb; i++) {
        const ni = Math.min(8, n - i * 8);
        for (let j = 0; j < ni; j++) {
            if (((u8[i] >> (7 - j)) & 0b00000001) !== 0)
                return false;
        }
    }
    return true;
}
const calcDifficulty = (claps) => BASE_DIFFICULTY + Math.round(Math.log2(BASE_CLAPS + claps));
export async function proofOfClap({ url, claps, id }) {
    const difficulty = calcDifficulty(claps);
    let nonce = 0;
    const key = new Uint32Array(await makeKey({ url, id, claps, nonce }));
    let hash = await sha256(key);
    while (!leadingZeros(hash, difficulty)) {
        nonce++;
        key[key.length - 1] = nonce;
        hash = await sha256(key);
    }
    return nonce;
}
export async function checkProofOfClap({ url, claps, id, nonce }) {
    const difficulty = calcDifficulty(claps);
    const hash = await sha256(await makeKey({ url, id, claps, nonce }));
    return leadingZeros(hash, difficulty);
}
//# sourceMappingURL=index.js.map