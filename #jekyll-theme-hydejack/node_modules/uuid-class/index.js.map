{"version":3,"file":"index.js","sourceRoot":"","sources":["src/index.ts"],"names":[],"mappings":"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","sourcesContent":["import { bufferSourceToUint8Array, bytesToHexArray, concatUint8Arrays, hexStringToBytes } from 'typed-array-utils';\n\nfunction _bytesToUUIDString(uint8Array: Uint8Array) {\n  const hexArray = bytesToHexArray(uint8Array);\n  hexArray.splice(4, 0, '-');\n  hexArray.splice(7, 0, '-');\n  hexArray.splice(10, 0, '-');\n  hexArray.splice(13, 0, '-');\n  return hexArray.join('');\n}\n\nfunction _v4() {\n  const uuid = crypto.getRandomValues(new Uint8Array(16));\n\n  // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n  uuid[6] = (uuid[6] & 0x0f) | 0x40;\n  uuid[8] = (uuid[8] & 0x3f) | 0x80;\n\n  return uuid.buffer;\n}\n\nfunction _fromString(str: string) {\n  const hex = str.replace(/[^0-9a-f]/gi, '').slice(0, 32);\n  if (hex.length < 32) throw Error('UUID too short');\n  return hexStringToBytes(hex).buffer;\n}\n\nfunction stringToBytes(str: string) {\n  str = unescape(encodeURIComponent(str)); // UTF8 escape\n  return new TextEncoder().encode(str);\n}\n\nasync function _v5(value: string | BufferSource, namespace: string | UUID) {\n  const valueBytes = typeof value === 'string'\n    ? stringToBytes(value)\n    : bufferSourceToUint8Array(value);\n\n  const namespaceUUID = typeof namespace === 'string'\n    ? new UUID(namespace)\n    : namespace\n\n  const hashBytes = new Uint8Array(\n    await crypto.subtle.digest('SHA-1', concatUint8Arrays(namespaceUUID, valueBytes))\n  );\n\n  hashBytes[6] = (hashBytes[6] & 0x0f) | 0x50; // version\n  hashBytes[8] = (hashBytes[8] & 0x3f) | 0x80;\n\n  return hashBytes.buffer.slice(0, 16);\n}\n\n/**\n * A better UUID class for JavaScript.\n * \n * UUID are represented as bytes (`Uint8Array`) and converted to strings on-demand.\n * \n * This class implements `toString` and `toJSON` for better language integration,\n * as well as inspection for node and Deno for a better development experience.\n * \n * For the most part, `UUID` can be used where  UUID strings are used,\n * except for equality checks. For those cases, `UUID` provides quick access \n * to the string representations via the `id` field.\n */\nexport class UUID extends Uint8Array {\n  /**\n   * Generate a new UUID version 4 (random).\n   * \n   * __Note that `crypto.getRandomValues` needs to be available in the global JS object!__\n   */\n  static v4() {\n    return new UUID(_v4());\n  }\n\n  /**\n   * Generated a new UUID version 5 (hashed)\n   * \n   * __Note that `crypto.subtle` needs to be available in the global JS object (Not the case on non-HTTPS sites)!__\n   * \n   * @param value \n   * @param namespace \n   */\n  static async v5(value: string | BufferSource, namespace: string | UUID) {\n    return new UUID(await _v5(value, namespace));\n  }\n\n  /**\n   * Generate a new UUID version 4 (random).\n   * __Note that `crypto.getRandomValues` needs to be available in the global JS object!__\n   */\n  constructor();\n  /** Creates a new UUID object from the provided string, which must be a valid UUID string. */\n  constructor(value: string);\n  /** Creates a copy of the provided UUID */\n  constructor(value: UUID);\n  /** Create a UUID from the provided iterable, where every value will be interpreted as a unsigned 8 bit integer. */\n  constructor(value: Iterable<number>);\n  /** Create a new UUID from the provided array-like structure. */\n  constructor(value: ArrayLike<number> | ArrayBufferLike);\n  /** Creates a UUID from the array buffer using 16 bytes started from the provided offset. */\n  constructor(value: ArrayBufferLike, byteOffset: number);\n  constructor(value?: string | UUID | Iterable<number> | ArrayLike<number> | ArrayBufferLike, byteOffset?: number) {\n    if (value == null) {\n      super(_v4());\n    } else if (typeof value === 'string') {\n      super(_fromString(value));\n    } else if (value instanceof UUID) {\n      super(value.buffer.slice(0));\n    } else {\n      const u8 = value instanceof ArrayBuffer || value instanceof SharedArrayBuffer \n        ? new Uint8Array(value, byteOffset ?? 0, 16)\n        : 'length' in value ? new Uint8Array(value) : new Uint8Array(value);\n      if (u8.length < 16) throw Error('UUID too short');\n      super(u8.buffer.slice(0, 16));\n    }\n  }\n\n  /**\n   * Quick access to the string representation for easier comparison.\n   * @example if (myUUID.id === otherUUID.id) { ... }\n   */\n  get id() {\n    return _bytesToUUIDString(this);\n  }\n\n  /**\n   * Quick access to the UUID string representation for easier comparison.\n   * @example if (myUUID.uuid === otherUUID.uuid) { ... }\n   */\n  get uuid() {\n    return _bytesToUUIDString(this);\n  }\n\n  toString() {\n    return _bytesToUUIDString(this);\n  }\n\n  toJSON() {\n    return _bytesToUUIDString(this);\n  }\n\n  // We don't operations like `map`, `subarray`, etc. to preserve the UUID class status\n  static get [Symbol.species]() { return Uint8Array }\n}\n\n// Better inspection for node and deno:\nconst nodeInspect = Symbol.for('nodejs.util.inspect.custom');\n\n// @ts-ignore\nconst denoInspect: symbol = typeof Deno !== 'undefined'\n  // @ts-ignore\n  ? 'symbols' in Deno ? Deno.symbols.customInspect : Deno.customInspect\n  : Symbol();\n\n// @ts-ignore\nUUID.prototype[nodeInspect] = function () { return `UUID [ ${this.uuid} ]` }\n\n// @ts-ignore\nUUID.prototype[denoInspect] = function () { return `UUID [ ${this.uuid} ]` }\n"]}